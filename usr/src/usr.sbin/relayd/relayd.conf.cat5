RELAYD.CONF(5)            OpenBSD Programmer's Manual           RELAYD.CONF(5)

NNAAMMEE
     rreellaayydd..ccoonnff - relay daemon configuration file

DDEESSCCRRIIPPTTIIOONN
     rreellaayydd..ccoonnff is the configuration file for the relay daemon, relayd(8).

SSEECCTTIIOONNSS
     rreellaayydd..ccoonnff is divided into six main sections:

     MMaaccrrooss
           User-defined variables may be defined and used later, simplifying
           the configuration file.

     GGlloobbaall CCoonnffiigguurraattiioonn
           Global settings for relayd(8).  Do note that the config file allows
           global settings to be added after defining tables in the config
           file, but those tables will use the built-in defaults instead of
           the global settings below them.

     TTaabblleess
           Table definitions describe a list of hosts, in a similar fashion to
           pf(4) tables.  They are used for relay, redirection, and router
           target selection with the described options and health checking on
           the host they contain.

     RReeddiirreeccttiioonnss
           Redirections are translated to pf(4) rdr-to rules for stateful
           forwarding to a target host from a health-checked table on layer 3.

     RReellaayyss
           Relays allow application layer load balancing, SSL acceleration,
           and general purpose TCP proxying on layer 7.

     PPrroottooccoollss
           Protocols are predefined protocol handlers and settings for relays.

     RRoouutteerrss
           Routers are used to insert routes with health-checked gateways for
           (WAN) link balancing.

     Within the sections, a host _a_d_d_r_e_s_s can be specified by IPv4 address,
     IPv6 address, interface name, or DNS hostname.  If the address is an
     interface name, relayd(8) will look up the first IPv4 address and any
     other IPv4 and IPv6 addresses of the specified network interface.  A _p_o_r_t
     can be specified by number or name.  The port name to number mappings are
     found in the file _/_e_t_c_/_s_e_r_v_i_c_e_s; see services(5) for details.

     Comments can be put anywhere in the file using a hash mark (`#'), and
     extend to the end of the current line.

     Additional configuration files can be included with the iinncclluuddee keyword,
     for example:

           include "/etc/relayd.conf.local"

MMAACCRROOSS
     Macros can be defined that will later be expanded in context.  Macro
     names must start with a letter, and may contain letters, digits, and
     underscores.  Macro names may not be reserved words (for example, ttaabbllee,
     rreellaayy, or ttiimmeeoouutt).  Macros are not expanded inside quotes.

     For example:

           www1="10.0.0.1"
           www2="10.0.0.2"
           table <webhosts> {
                   $www1
                   $www2
           }

GGLLOOBBAALL CCOONNFFIIGGUURRAATTIIOONN
     Here are the settings that can be set globally:

     ddeemmoottee _g_r_o_u_p
             Enable the global carp(4) demotion option, resetting the carp
             demotion counter for the specified interface group to zero on
             startup and to 128 on shutdown of the daemon.  For more
             information on interface groups, see the ggrroouupp keyword in
             ifconfig(8).

     iinntteerrvvaall _n_u_m_b_e_r
             Set the interval in seconds at which the hosts will be checked.
             The default interval is 10 seconds.

     lloogg (uuppddaatteess|aallll)
             Log state notifications after completed host checks.  Either only
             log the uuppddaatteess to new states or log aallll state notifications,
             even if the state didn't change.  The host state can be _u_p (the
             health check completed successfully), _d_o_w_n (the host is down or
             didn't match the check criteria), or _u_n_k_n_o_w_n (the host is
             disabled or has not been checked yet).

     pprreeffoorrkk _n_u_m_b_e_r
             When using relays, run the specified number of processes to
             handle relayed connections.  This increases the performance and
             prevents delays when connecting to a relay.  relayd(8) runs 5
             relay processes by default and every process will handle all
             configured relays.

     sseenndd ttrraapp
             Send an SNMP trap when the state of a host changes.  relayd(8)
             will try to connect to snmpd(8) and request it send a trap to the
             registered trap receivers; see snmpd.conf(5) for more information
             about the configuration.

     ttiimmeeoouutt _n_u_m_b_e_r
             Set the global timeout in milliseconds for checks.  This can be
             overridden by the timeout value in the table definitions.  The
             default interval is 200 milliseconds and it must not exceed the
             global interval.  Please note that the default value is optimized
             for checks within the same collision domain - use a higher
             timeout, such as 1000 milliseconds, for checks of hosts in other
             subnets.  If this option is to be set, it should be placed before
             overrides in tables.

TTAABBLLEESS
     Tables are used to group a set of hosts as the target for redirections or
     relays; they will be mapped to a pf(4) table for redirections.  Tables
     may be defined with the following attribute:

     ddiissaabbllee  Start the table disabled - no hosts will be checked in this
              table.  The table can be later enabled through relayctl(8).

     Each table must contain at least one host; multiple hosts are separated
     by newline, comma, or whitespace.  Host entries may be defined with the
     following attributes:

     iipp ttttll _n_u_m_b_e_r
            Change the default time-to-live value in the IP headers for host
            checks.

     ppaarreenntt _n_u_m_b_e_r
            The optional parent option inherits the state from a parent host
            with the specified identifier.  The check will be skipped for this
            host and copied from the parent host.  This can be used to prevent
            multiple checks on hosts with multiple IP addresses for the same
            service.  The host identifiers are sequentially assigned to the
            configured hosts starting with 1; it can be shown with the
            relayctl(8) sshhooww ssuummmmaarryy commands.

     rreettrryy _n_u_m_b_e_r
            The optional retry option adds a tolerance for failed host checks;
            the check will be retried for _n_u_m_b_e_r more times before setting the
            host state to down.  If this table is used by a relay, it will
            also specify the number of retries for outgoing connection
            attempts.

     For example:

           table <service> { 192.168.1.1, 192.168.1.2, 192.168.2.3 }
           table <fallback> disable { 10.1.5.1 retry 2 }

           redirect "www" {
                   listen on www.example.com port 80
                   forward to <service> check http "/" code 200
                   forward to <fallback> check http "/" code 200
           }

     Tables are used by ffoorrwwaarrdd ttoo directives in redirections or relays with a
     set of general options, health-checking rules, and timings; see the
     _R_E_D_I_R_E_C_T_I_O_N_S and _R_E_L_A_Y_S sections for more information about the forward
     context.  Table specific configuration directives are described below.
     Multiple options can be appended to ffoorrwwaarrdd ttoo directives, separated by
     whitespaces.

     The following options will configure the health-checking method for the
     table, and is mandatory for redirections:

     cchheecckk hhttttpp _p_a_t_h [hhoosstt _h_o_s_t_n_a_m_e] ccooddee _n_u_m_b_e_r
             For each host in the table, verify that retrieving the URL _p_a_t_h
             gives the HTTP return code _n_u_m_b_e_r.  If _h_o_s_t_n_a_m_e is specified, it
             is used as the ``Host:'' header to query a specific hostname at
             the target host.  To validate the HTTP return code, use this
             shell command:

                   $ echo -n "HEAD <path> HTTP/1.0\r\n\r\n" | \
                           nc <host> <port> | head -n1

             This prints the status header including the actual return code:

                   HTTP/1.1 200 OK

     cchheecckk hhttttppss _p_a_t_h [hhoosstt _h_o_s_t_n_a_m_e] ccooddee _n_u_m_b_e_r
             This has the same effect as above but wraps the HTTP request in
             SSL.

     cchheecckk hhttttpp _p_a_t_h [hhoosstt _h_o_s_t_n_a_m_e] ddiiggeesstt _s_t_r_i_n_g
             For each host in the table, verify that retrieving the URL _p_a_t_h
             produces non-binary content whose message digest matches the
             defined string.  The algorithm used is determined by the string
             length of the _d_i_g_e_s_t argument, either SHA1 (40 characters) or MD5
             (32 characters).  If _h_o_s_t_n_a_m_e is specified, it is used as the
             ``Host:'' header to query a specific hostname at the target host.
             The digest does not take the HTTP headers into account.  Do not
             specify a binary object (such as a graphic) as the target of the
             request, as rreellaayydd..ccoonnff expects the data returned to be a string.
             To compute the digest, use this simple command:

                   $ ftp -o - http://host[:port]/path | sha1

             This gives a digest that can be used as-is in a digest statement:

                   a9993e36476816aba3e25717850c26c9cd0d89d

     cchheecckk hhttttppss _p_a_t_h [hhoosstt _h_o_s_t_n_a_m_e] ddiiggeesstt _s_t_r_i_n_g
             This has the same effect as above but wraps the HTTP request in
             SSL.

     cchheecckk iiccmmpp
             Ping hosts in this table to determine whether they are up or not.
             This method will automatically use ICMP or ICMPV6 depending on
             the address family of each host.

     cchheecckk ssccrriipptt _p_a_t_h
             Execute an external program to check the host state.  The program
             will be executed for each host by specifying the hostname on the
             command line:

                   /usr/local/bin/checkload.pl front-www1.private.example.com

             relayd(8) expects a positive return value on success and zero on
             failure.  Note that the script will be executed with the
             privileges of the "_relayd" user and terminated after _t_i_m_e_o_u_t
             milliseconds.

     cchheecckk sseenndd _d_a_t_a eexxppeecctt _p_a_t_t_e_r_n [ssssll]
             For each host in the table, a TCP connection is established on
             the port specified, then _d_a_t_a is sent.  Incoming data is then
             read and is expected to match against _p_a_t_t_e_r_n using shell
             globbing rules.  If _d_a_t_a is an empty string or nnootthhiinngg then
             nothing is sent on the connection and data is immediately read.
             This can be useful with protocols that output a banner like SMTP,
             NNTP, and FTP.  If the ssssll keyword is present, the transaction
             will occur in an SSL tunnel.

     cchheecckk ssssll
             Perform a complete SSL handshake with each host to check their
             availability.

     cchheecckk ttccpp
             Use a simple TCP connect to check that hosts are up.

     The following general table options are available:

     ddeemmoottee _g_r_o_u_p
             Enable the per-table carp(4) demotion option.  This will
             increment the carp demotion counter for the specified interface
             group if all hosts in the table are down.  For more information
             on interface groups, see the ggrroouupp keyword in ifconfig(8).

     iinntteerrvvaall _n_u_m_b_e_r
             Override the global interval and specify one for this table.  It
             must be a multiple of the global interval.

     ttiimmeeoouutt _n_u_m_b_e_r
             Set the timeout in milliseconds for each host that is checked
             using TCP as the transport.  This will override the global
             timeout, which is 200 milliseconds by default.

     The following options will set the scheduling algorithm to select a host
     from the specified table:

     mmooddee hhaasshh
             Balances the outgoing connections across the active hosts based
             on the hashed name of the table.  Additional input can be fed
             into the hash by looking at HTTP headers and GET variables; see
             the _P_R_O_T_O_C_O_L_S section below.  This mode is only supported by
             relays.

     mmooddee llooaaddbbaallaannccee
             Balances the outgoing connections across the active hosts based
             on the hashed name of the table, the source and destination
             addresses, and the corresponding ports.  This mode is only
             supported by relays.

     mmooddee rroouunnddrroobbiinn
             Distributes the outgoing connections using a round-robin
             scheduler through all active hosts.  This is the default mode and
             will be used if no option has been specified.  This mode is
             supported by redirections and relays.

RREEDDIIRREECCTTIIOONNSS
     Redirections represent a pf(4) rdr-to rule.  They are used for stateful
     redirections to the hosts in the specified tables.  pf(4) rewrites the
     target IP addresses and ports of the incoming connections, operating on
     layer 3.  The configuration directives that are valid in the rreeddiirreecctt
     context are described below:

     ddiissaabbllee
             The redirection is initially disabled.  It can be later enabled
             through relayctl(8).

     ffoorrwwaarrdd ttoo <_t_a_b_l_e> [ppoorrtt _n_u_m_b_e_r] _o_p_t_i_o_n_s _._._.
             Specify the tables of target hosts to be used; see the _T_A_B_L_E_S
             section above for information about table options.  If the ppoorrtt
             option is not specified, the first port from the lliisstteenn oonn
             directive will be used.  This directive can be specified twice -
             the second entry will be used as the backup table if all hosts in
             the main table are down.  At least one entry for the main table
             is mandatory.

     lliisstteenn oonn _a_d_d_r_e_s_s [ip-proto] ppoorrtt _p_o_r_t [iinntteerrffaaccee _n_a_m_e]
             Specify an _a_d_d_r_e_s_s and a _p_o_r_t to listen on.  pf(4) will redirect
             incoming connections for the specified target to the hosts in the
             main or backup table.  The _p_o_r_t argument can optionally specify a
             port range instead of a single port; the format is
             _m_i_n_-_p_o_r_t:_m_a_x_-_p_o_r_t.  The optional argument _i_p_-_p_r_o_t_o can be used to
             specify an IP protocol like _t_c_p or _u_d_p; it defaults to _t_c_p.  The
             rule can be optionally restricted to a given interface name.

     rroouuttee ttoo <_t_a_b_l_e> [ppoorrtt _n_u_m_b_e_r] _o_p_t_i_o_n_s _._._.
             Like the ffoorrwwaarrdd ttoo directive, but directly routes the packets to
             the target host without modifying the target address using a
             pf(4) route-to rule.  This can be used for ``direct server
             return'' to force the target host to respond via a different
             gateway.  Note that hosts have to accept sessions for the same
             address as the gateway, which is typically done by configuring a
             loopback interface on the host with this address.

     sseessssiioonn ttiimmeeoouutt _s_e_c_o_n_d_s
             Specify the inactivity timeout in seconds for established
             redirections.  The default timeout is 600 seconds (10 minutes).

     ssttiicckkyy--aaddddrreessss
             This has the same effect as specifying sticky-address for an rdr-
             to rule in pf.conf(5).  It will ensure that multiple connections
             from the same source are mapped to the same redirection address.

     [mmaattcchh] ttaagg _n_a_m_e
             Automatically tag packets passing through the pf(4) rdr-to rule
             with the name supplied.  This allows simpler filter rules.  The
             optional mmaattcchh keyword will change the default rule action from
             _p_a_s_s _i_n _q_u_i_c_k to _m_a_t_c_h _i_n to allow further evaluation in the pf
             ruleset using the _t_a_g_g_e_d _n_a_m_e rule option.

RREELLAAYYSS
     Relays will forward traffic between a client and a target server.  In
     contrast to redirections and IP forwarding in the network stack, a relay
     will accept incoming connections from remote clients as a server, open an
     outgoing connection to a target host, and forward any traffic between the
     target host and the remote client, operating on layer 7.  A relay is also
     called an application layer gateway or layer 7 proxy.

     The main purpose of a relay is to provide advanced load balancing
     functionality based on specified protocol characteristics, such as HTTP
     headers, to provide SSL acceleration and to allow basic handling of the
     underlying application protocol.

     The rreellaayy configuration directives are described below:

     ddiissaabbllee
             Start the relay but immediately close any accepted connections.

     [ttrraannssppaarreenntt] ffoorrwwaarrdd [wwiitthh ssssll] ttoo _a_d_d_r_e_s_s [ppoorrtt _p_o_r_t] _o_p_t_i_o_n_s _._._.
             Specify the address and port of the target host to connect to.
             If the ppoorrtt option is not specified, the port from the lliisstteenn oonn
             directive will be used.  Use the ttrraannssppaarreenntt keyword to enable
             fully-transparent mode; the source address of the client will be
             retained in this case.

             The wwiitthh ssssll directive enables client-side SSL mode to connect to
             the remote host.  Verification of server certificates can be
             enabled by setting the ccaa ffiillee option in the protocol section.

             The following options may be specified for forward directives:

             rreettrryy _n_u_m_b_e_r
                     The optional host rreettrryy option will be used as a
                     tolerance for failed host connections; the connection
                     will be retried for _n_u_m_b_e_r more times.

             iinneett    If the requested destination is an IPv6 address,
                     relayd(8) will forward the connection to an IPv4 address
                     which is determined by the last 4 octets of the original
                     IPv6 destination.  For example, if the original IPv6
                     destination address is 2001:db8:7395:ffff::a01:101, the
                     session is relayed to the IPv4 address 10.1.1.1
                     (a01:101).

             iinneett66 _a_d_d_r_e_s_s_-_p_r_e_f_i_x
                     If the requested destination is an IPv4 address,
                     relayd(8) will forward the connection to an IPv6 address
                     which is determined by setting the last 4 octets of the
                     specified IPv6 _a_d_d_r_e_s_s_-_p_r_e_f_i_x to the 4 octets of the
                     original IPv4 destination.  For example, if the original
                     IPv4 destination address is 10.1.1.1 and the specified
                     address prefix is 2001:db8:7395:ffff::, the session is
                     relayed to the IPv6 address 2001:db8:7395:ffff::a01:101.

     ffoorrwwaarrdd ttoo <_t_a_b_l_e> [ppoorrtt _p_o_r_t] _o_p_t_i_o_n_s _._._.
             Like the previous directive, but connect to a host from the
             specified table; see the _T_A_B_L_E_S section above for information
             about table options.  This directive can be specified twice - the
             second entry will be used as the backup table if all hosts in the
             main table are down.  At least one entry for the main table is
             mandatory.

     ffoorrwwaarrdd ttoo nnaatt llooookkuupp _o_p_t_i_o_n_s _._._.
             When redirecting connections with an rdr-to rule in pf.conf(5) to
             a relay listening on localhost, this directive will look up the
             real destination address of the intended target host, allowing
             the relay to be run as a transparent proxy.  If an additional
             ffoorrwwaarrdd ttoo directive to a specified address or table is present,
             it will be used as a backup if the NAT lookup failed.

     lliisstteenn oonn _a_d_d_r_e_s_s [ppoorrtt _p_o_r_t] [ssssll]
             Specify the address and port for the relay to listen on.  The
             relay will accept incoming connections to the specified address.
             If the ppoorrtt option is not specified, the port from the lliisstteenn oonn
             directive will be used.

             If the ssssll keyword is present, the relay will accept connections
             using the encrypted SSL protocol.  The relay will look up a
             private key in _/_e_t_c_/_s_s_l_/_p_r_i_v_a_t_e_/_a_d_d_r_e_s_s_._k_e_y and a public
             certificate in _/_e_t_c_/_s_s_l_/_a_d_d_r_e_s_s_._c_r_t, where _a_d_d_r_e_s_s is the
             specified IP address of the relay to listen on.  See ssl(8) for
             details about SSL server certificates.

     pprroottooccooll _n_a_m_e
             Use the specified protocol definition for the relay.  The generic
             TCP protocol options will be used by default; see the _P_R_O_T_O_C_O_L_S
             section below.

     sseessssiioonn ttiimmeeoouutt _s_e_c_o_n_d_s
             Specify the inactivity timeout in seconds for accepted sessions.
             The default timeout is 600 seconds (10 minutes).

PPRROOTTOOCCOOLLSS
     Protocols are templates defining actions and settings for relays.  They
     allow setting generic TCP options, SSL settings, and actions specific to
     the selected application layer protocol.

     The protocol directive is available for a number of different application
     layer protocols.  There is no generic handler for UDP-based protocols
     because it is a stateless datagram-based protocol which has to look into
     the application layer protocol to find any possible state information.

     ddnnss pprroottooccooll
             (UDP) Domain Name System (DNS) protocol.  The requested IDs in
             the DNS header will be used to match the state.  relayd(8)
             replaces these IDs with random values to compensate for
             predictable values generated by some hosts.

     hhttttpp pprroottooccooll
             Handle the HyperText Transfer Protocol (HTTP, or "HTTPS" if
             encapsulated in an SSL tunnel).

     [ttccpp] pprroottooccooll
             Generic handler for TCP-based protocols.  This is the default.

     The available configuration directives are described below:

     [_d_i_r_e_c_t_i_o_n] [_t_y_p_e] _a_c_t_i_o_n [mmaarrkkeedd _i_d] [lloogg]
             Define an action for the selected entity.  The optional lloogg
             keyword will log the entity name and the value and the optional
             mmaarrkkeedd keyword requires that the session has been marked with a
             given identifier in order to execute the action.  The actions are
             dependent on the underlying application pprroottooccooll.

     [_d_i_r_e_c_t_i_o_n] may be one of:

     rreeqquueesstt
             Handle the data stream from the client to the relay, like HTTP
             requests.  This is the default if the _d_i_r_e_c_t_i_o_n directive is
             omitted.

     rreessppoonnssee
             Handle the data stream from the target host to the relay, like
             HTTP server replies.

     [_t_y_p_e] may be one of:

     ccooookkiiee  Look up the entity as a value in the Cookie header when using the
             hhttttpp protocol.  This type is only available with the direction
             rreeqquueesstt.

     hheeaaddeerr  Look up the entity in the application protocol headers, like HTTP
             headers in hhttttpp mode.

     ppaatthh    Look up the entity as a value in the URL path when using the hhttttpp
             protocol.  This type is only available with the direction
             rreeqquueesstt.  The _k_e_y will match the path of the requested URL
             without the hostname and query and the value will match the
             complete query, for example:

                   request path filter "/index.html"
                   request path filter "foo=bar*" from "/cgi-bin/t.cgi"

     qquueerryy   Look up the entity as a query variable in the URL when using the
             hhttttpp protocol.  This type is only available with the direction
             rreeqquueesstt, for example:

                   # Will match /cgi-bin/example.pl?foo=bar&ok=yes
                   request query expect "bar" from "foo"

     uurrll     Look up the entity as a URL suffix/prefix expression consisting
             of a canonicalized hostname without port or suffix and a path
             name or prefix when using the hhttttpp protocol.  This type is only
             available with the direction rreeqquueesstt, for example:

                   request url filter "example.com/index.html"
                   request url filter "example.com/test.cgi?val=1"

             relayd(8) will match the full URL and different possible
             suffix/prefix combinations by stripping subdomains and path
             components (up to 5 levels), and the query string.  For example,
             the following lookups will be done for
             _h_t_t_p_:_/_/_w_w_w_._e_x_a_m_p_l_e_._c_o_m_:_8_1_/_1_/_2_/_3_/_4_/_5_._h_t_m_l_?_q_u_e_r_y_=_y_e_s:

                   www.example.com/1/2/3/4/5.html?query=yes
                   www.example.com/1/2/3/4/5.html
                   www.example.com/
                   www.example.com/1/
                   www.example.com/1/2/
                   www.example.com/1/2/3/
                   example.com/1/2/3/4/5.html?query=yes
                   example.com/1/2/3/4/5.html
                   example.com/
                   example.com/1/
                   example.com/1/2/
                   example.com/1/2/3/

     [_a_c_t_i_o_n] may be one of:

     aappppeenndd _v_a_l_u_e ttoo _k_e_y
             Append the specified value to a protocol entity with the selected
             name.  When using the hhttttpp protocol, kkeeyy will indicate a
             specified HTTP header.  If _k_e_y does not exist in the request, it
             will be created with the value set to _v_a_l_u_e.

             The _v_a_l_u_e string may contain predefined macros that will be
             expanded at runtime:

                   $$RREEMMOOTTEE__AADDDDRR  The IP address of the connected client.
                   $$RREEMMOOTTEE__PPOORRTT  The TCP source port of the connected client.
                   $$SSEERRVVEERR__AADDDDRR  The configured IP address of the relay.
                   $$SSEERRVVEERR__PPOORRTT  The configured TCP server port of the relay.
                   $$SSEERRVVEERR__NNAAMMEE  The server software name of relayd(8).
                   $$TTIIMMEEOOUUTT      The configured session timeout of the relay.

     cchhaannggee _k_e_y ttoo _v_a_l_u_e
             Like the aappppeenndd directive above, but change the contents of the
             specified entity.  If _k_e_y does not exist in the request, it will
             be created with the value set to _v_a_l_u_e.

             The _v_a_l_u_e string may contain predefined macros that will be
             expanded at runtime, as detailed for the aappppeenndd directive above.

     eexxppeecctt _v_a_l_u_e ffrroomm _k_e_y
             Expect an entity _k_e_y and match against _v_a_l_u_e using shell globbing
             rules.  If the entity is not present or the value doesn't match,
             the connection will be dropped.

     eexxppeecctt [ddiiggeesstt] _k_e_y
             Expect an entity _k_e_y with any possible value.  This is the short
             form of eexxppeecctt _* ffrroomm _k_e_y.

             If the ddiiggeesstt keyword is specified, compare the message digest of
             the entity against the defined string.  The algorithm used is
             determined by the string length of the _k_e_y argument, either SHA1
             (40 characters) or MD5 (32 characters).  To compute the digest,
             use this simple command:

                   $ echo -n "example.com/path/?args" | sha1

     eexxppeecctt ffiillee _p_a_t_h
             Like the directive above, but load the non-digest keys from an
             external file with the specified _p_a_t_h containing one key per
             line.  Lines will be stripped at the first whitespace or newline
             character.  Any empty lines or lines beginning with a hash mark
             (`#') will be ignored.

     ffiilltteerr _v_a_l_u_e ffrroomm _k_e_y
             Like the eexxppeecctt _._. ffrroomm directive above, but drop any connections
             with the specified entity _k_e_y and a matching _v_a_l_u_e.

     ffiilltteerr [ddiiggeesstt] _k_e_y
             Like the eexxppeecctt directive above, but drop any connections with
             the specified entity _k_e_y and any possible value.  This is the
             short form of ffiilltteerr _* ffrroomm _k_e_y.

     ffiilltteerr ffiillee _p_a_t_h
             Like the directive above, but load the non-digest keys from _p_a_t_h.
             See eexxppeecctt ffiillee _p_a_t_h for more information.

     hhaasshh _k_e_y
             Feed the value of the selected entity into the load balancing
             hash to select the target host.  See the ttaabbllee keyword in the
             _R_E_L_A_Y_S section above.

     lloogg _k_e_y
             Log the name and the value of the entity.

     lloogg ffiillee _p_a_t_h
             Like the directive above, but load the keys from _p_a_t_h.  See
             eexxppeecctt ffiillee _p_a_t_h for more information.

     mmaarrkk [_v_a_l_u_e ffrroomm] _k_e_y wwiitthh _i_d
             Mark the session with the specified identifier (a positive number
             between 1 and 65535) if the specified condition matches.  Note
             that the mmaarrkk action does not accept the mmaarrkkeedd option (see
             above).

     llaabbeell _s_t_r_i_n_g
             Add a label to subsequently added actions.  The label will be
             printed as part of the error message if the rreettuurrnn eerrrroorr option
             is set and may contain HTML tags, for example:

                   label "<a href='http://example.com/advisory.pl?id=7359'>\
                           Advisory provided by example.com</a>"
                   url filter digest 5c1e03f58f8ce0b457474ffb371fd1ef
                   url filter digest 80c1a7b8337462093ef8359c57b4d56a
                   no label

     nnoo llaabbeell
             Do not set a label for subsequently added actions; this is the
             default.

     rreemmoovvee _k_e_y
             Remove the entity with the selected name.

     rreemmoovvee ffiillee _p_a_t_h
             Like the directive above, but load the keys from _p_a_t_h.  See
             eexxppeecctt ffiillee _p_a_t_h for more information.

     rreettuurrnn eerrrroorr [_o_p_t_i_o_n]
             Return an error response to the client if an internal operation
             or the forward connection to the client failed.  By default, the
             connection will be silently dropped.  The effect of this option
             depends on the protocol: HTTP will send an error header and page
             to the client before closing the connection.  Additional valid
             options are:

             ssttyyllee _s_t_r_i_n_g
                     Specify a Cascading Style Sheet (CSS) to be used for the
                     returned HTTP error pages, for example:

                           body { background: #a00000; color: white; }

     ssssll _o_p_t_i_o_n
             Set the SSL options and session settings.  This is only used if
             SSL is enabled in the relay.  Valid options are:

             ccaa ffiillee _p_a_t_h
                     This option enables CA verification in SSL client mode.
                     The daemon will load the CA (Certificate Authority)
                     certificates from the specified path to verify the server
                     certificates.  OpenBSD provides a default CA bundle in
                     _/_e_t_c_/_s_s_l_/_c_e_r_t_._p_e_m.

             cciipphheerrss _s_t_r_i_n_g
                     Set the string defining the SSL cipher suite.  If not
                     specified, the default value _H_I_G_H_:_!_A_D_H will be used
                     (strong crypto cipher suites without anonymous DH).  See
                     the _C_I_P_H_E_R_S section of openssl(1) for information about
                     SSL cipher suites and preference lists.

             sseessssiioonn ccaacchhee _v_a_l_u_e
                     Set the maximum size of the SSL session cache.  If the
                     _v_a_l_u_e is zero, the default size defined by the SSL
                     library will be used.  A positive number will set the
                     maximum size in bytes and the keyword ddiissaabbllee will
                     disable the SSL session cache.

             [nnoo] ssssllvv22
                     Enable the SSLv2 protocol; disabled by default.

             [nnoo] ssssllvv33
                     Disable the SSLv3 protocol; enabled by default.

             [nnoo] ttllssvv11
                     Disable the TLSv1/SSLv3.1 protocol; enabled by default.

     ttccpp _o_p_t_i_o_n
             Enable or disable the specified TCP/IP options; see tcp(4) and
             ip(4) for more information about the options.  Valid options are:

             bbaacckklloogg _n_u_m_b_e_r
                     Set the maximum length the queue of pending connections
                     may grow to.  The backlog option is 10 by default and is
                     limited by the kkeerrnn..ssoommaaxxccoonnnn sysctl(8) variable.

             iipp mmiinnttttll _n_u_m_b_e_r
                     This option for the underlying IP connection may be used
                     to discard packets with a TTL lower than the specified
                     value.  This can be used to implement the _G_e_n_e_r_a_l_i_z_e_d _T_T_L
                     _S_e_c_u_r_i_t_y _M_e_c_h_a_n_i_s_m _(_G_T_S_M_) according to RFC 3682.

             iipp ttttll _n_u_m_b_e_r
                     Change the default time-to-live value in the IP headers.

             [nnoo] nnooddeellaayy
                     Enable the TCP NODELAY option for this connection.  This
                     is recommended to avoid delays in the relayed data
                     stream, e.g. for SSH connections.

             [nnoo] ssaacckk
                     Use selective acknowledgements for this connection.

             ssoocckkeett bbuuffffeerr _n_u_m_b_e_r
                     Set the socket-level buffer size for input and output for
                     this connection.  This will affect the TCP window size.

RROOUUTTEERRSS
     Routers represent routing table entries in the kernel forwarding
     database, see route(4), and a table of associated gateways.  They are
     used to dynamically insert or remove routes with gateways based on their
     availability and health-check results.  A router can include multiple
     network statements and a single forward statement with a table of one or
     more gateways.  All entries in a single router directive must match the
     same address family, either IPv4 or IPv6.

     The kernel supports multipath routing when multiple gateways exist to the
     same destination address.  The multipath routing behaviour can be changed
     globally using the sysctl(8) variables _n_e_t_._i_n_e_t_._i_p_._m_u_l_t_i_p_a_t_h and
     _n_e_t_._i_n_e_t_6_._i_p_6_._m_u_l_t_i_p_a_t_h.  With the default setting of 0, the first route
     selected will be used for subsequent packets to that destination
     regardless of source.  Setting it to 1 will enable load balancing based
     on the packet source address across gateways; multiple routes with the
     same priority are used equally.  The kernel will also check the link
     state of the related network interface and try a different route if it is
     not active.

     The configuration directives that are valid in the rroouutteerrss context are
     described below:

     ffoorrwwaarrdd ttoo <_t_a_b_l_e> ppoorrtt _n_u_m_b_e_r _o_p_t_i_o_n_s _._._.
             Specify the table of target gateways to be used; see the _T_A_B_L_E_S
             section above for information about table options.  This entry is
             mandatory and must be specified once.

     rroouuttee _a_d_d_r_e_s_s/_p_r_e_f_i_x
             Specify the network address and prefix length of a route
             destination that is reachable via the active gateways.  This
             entry must be specified at least once in a router directive.

     rrttaabbllee _i_d
             Add the routes to the kernel routing table with the specified _i_d.

     rrttllaabbeell _l_a_b_e_l
             Add the routes with the specified _l_a_b_e_l to the kernel routing
             table.

FFIILLEESS
     _/_e_t_c_/_r_e_l_a_y_d_._c_o_n_f                relayd(8) configuration file.

     _/_e_t_c_/_s_e_r_v_i_c_e_s                   Service name database.

     _/_e_t_c_/_s_s_l_/_a_d_d_r_e_s_s_._c_r_t
     _/_e_t_c_/_s_s_l_/_p_r_i_v_a_t_e_/_a_d_d_r_e_s_s_._k_e_y    Location of the relay SSL server
                                     certificates, where _a_d_d_r_e_s_s is the
                                     configured IP address of the relay.
     _/_e_t_c_/_s_s_l_/_c_e_r_t_._p_e_m               Default location of the CA bundle that
                                     can be used with relayd(8).

EEXXAAMMPPLLEESS
     This configuration file would create a redirection service ``www'' which
     load balances four hosts and falls back to one host containing a ``sorry
     page'':

           www1=front-www1.private.example.com
           www2=front-www2.private.example.com
           www3=front-www3.private.example.com
           www4=front-www4.private.example.com

           interval 5

           table <phphosts> { $www1, $www2, $www3, $www4 }
           table <sorryhost> disable { sorryhost.private.example.com }

           redirect "www" {
                   listen on www.example.com port 8080 interface trunk0
                   listen on www6.example.com port 80 interface trunk0

                   tag REDIRECTED

                   forward to <phphosts> port 8080 timeout 300 \
                           check http "/" digest "630aa3c2f..."
                   forward to <sorryhost> port 8080 timeout 300 check icmp
           }

     It is possible to specify multiple listen directives with different IP
     protocols in a single redirection configuration:

           redirect "dns" {
                   listen on dns.example.com tcp port 53
                   listen on dns.example.com udp port 53

                   forward to <dnshosts> port 53 check tcp
           }

     The following configuration would add a relay to forward secure HTTPS
     connections to a pool of HTTP webservers using the llooaaddbbaallaannccee mode (SSL
     acceleration and layer 7 load balancing).  The HTTP protocol definition
     will add two HTTP headers containing address information of the client
     and the server, set the ``Keep-Alive'' header value to the configured
     session timeout, and include the ``sessid'' variable in the hash to
     calculate the target host:

           http protocol "http_ssl" {
                   header append "$REMOTE_ADDR" to "X-Forwarded-For"
                   header append "$SERVER_ADDR:$SERVER_PORT" to "X-Forwarded-By"
                   header change "Keep-Alive" to "$TIMEOUT"
                   query hash "sessid"
                   cookie hash "sessid"
                   path filter "*command=*" from "/cgi-bin/index.cgi"

                   ssl { sslv2, ciphers "MEDIUM:HIGH" }
           }

           relay "sslaccel" {
                   listen on www.example.com port 443 ssl
                   protocol "http_ssl"
                   forward to <phphosts> port 8080 mode loadbalance check tcp
           }

     The second relay example will accept incoming connections to port 2222
     and forward them to a remote SSH server.  The TCP nnooddeellaayy option will
     allow a ``smooth'' SSH session without delays between keystrokes or
     displayed output on the terminal:

           protocol "myssh" {
                   tcp { nodelay, socket buffer 65536 }
           }

           relay "sshforward" {
                   listen on www.example.com port 2222
                   protocol "myssh"
                   forward to shell.example.com port 22
           }

     The next simple router configuration example can be used to run
     redundant, health-checked WAN links:

           table <gateways> { $gw1 ip ttl 1, $gw2 ip ttl 1 }
           router "uplinks" {
                   route 0.0.0.0/0
                   forward to <gateways> check icmp
           }

SSEEEE AALLSSOO
     relayctl(8), relayd(8), snmpd(8), ssl(8)

HHIISSTTOORRYY
     The rreellaayydd..ccoonnff file format, formerly known as hhoossttssttaatteedd..ccoonnff, first
     appeared in OpenBSD 4.1.  It was renamed to rreellaayydd..ccoonnff in OpenBSD 4.3.

AAUUTTHHOORRSS
     The relayd(8) program was written by Pierre-Yves Ritschard
     <pyr@openbsd.org> and Reyk Floeter <reyk@openbsd.org>.

CCAAVVEEAATTSS
     relayd(8) Verification of SSL server certificates is based on a static CA
     bundle and relayd(8) currently does not support CRLs (Certificate
     Revocation Lists).

OpenBSD 4.9                    October 26, 2010                    OpenBSD 4.9
